vector_1 ()
{
  struct array03_real(kind=8) a;
  struct array03_real(kind=8) b;
  integer(kind=4) i;
  integer(kind=4) j;
  integer(kind=4) k;

  a.data = 0B;
  b.data = 0B;
  {
    integer(kind=4) overflow.0;
    integer(kind=4) overflow.1;

    a.dtype = {.elem_len=8, .rank=3, .type=3};
    overflow.0 = 0;
    if (__builtin_expect ((integer(kind=8)) (overflow.0 != 0), 0, 39))
      {
        _gfortran_runtime_error (&"Integer overflow when calculating the amount of memory to allocate"[1]{lb: 1 sz: 1});
      }
    else
      {
        if (__builtin_expect ((integer(kind=8)) (a.data != 0B), 0, 41))
          {
            _gfortran_runtime_error_at (&"At line 10 of file vectorization.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"a"[1]{lb: 1 sz: 1});
          }
        else
          {
            a.data = (void * restrict) __builtin_malloc (8000000000);
            if (__builtin_expect ((integer(kind=8)) (a.data == 0B), 0, 40))
              {
                _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
              }
          }
      }
    a.dim[0].lbound = 1;
    a.dim[0].ubound = 1000;
    a.dim[0].stride = 1;
    a.dim[1].lbound = 1;
    a.dim[1].ubound = 1000;
    a.dim[1].stride = 1000;
    a.dim[2].lbound = 1;
    a.dim[2].ubound = 1000;
    a.dim[2].stride = 1000000;
    a.offset = -1001001;
    b.dtype = {.elem_len=8, .rank=3, .type=3};
    overflow.1 = 0;
    if (__builtin_expect ((integer(kind=8)) (overflow.1 != 0), 0, 39))
      {
        _gfortran_runtime_error (&"Integer overflow when calculating the amount of memory to allocate"[1]{lb: 1 sz: 1});
      }
    else
      {
        if (__builtin_expect ((integer(kind=8)) (b.data != 0B), 0, 41))
          {
            _gfortran_runtime_error_at (&"At line 10 of file vectorization.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"b"[1]{lb: 1 sz: 1});
          }
        else
          {
            b.data = (void * restrict) __builtin_malloc (8000000000);
            if (__builtin_expect ((integer(kind=8)) (b.data == 0B), 0, 40))
              {
                _gfortran_os_error (&"Allocation would exceed memory limit"[1]{lb: 1 sz: 1});
              }
          }
      }
    b.dim[0].lbound = 1;
    b.dim[0].ubound = 1000;
    b.dim[0].stride = 1;
    b.dim[1].lbound = 1;
    b.dim[1].ubound = 1000;
    b.dim[1].stride = 1000;
    b.dim[2].lbound = 1;
    b.dim[2].ubound = 1000;
    b.dim[2].stride = 1000000;
    b.offset = -1001001;
    i = 1;
    while (1)
      {
        {
          logical(kind=4) D.3795;

          D.3795 = i > 1000;
          if (D.3795) goto L.2;
          j = 1;
          while (1)
            {
              {
                logical(kind=4) D.3798;

                D.3798 = j > 1000;
                if (D.3798) goto L.4;
                k = 1;
                while (1)
                  {
                    {
                      logical(kind=4) D.3801;

                      D.3801 = k > 1000;
                      if (D.3801) goto L.6;
                      (*(real(kind=8)[0:] * restrict) a.data)[((a.offset + (integer(kind=8)) k * a.dim[2].stride) + (integer(kind=8)) j * a.dim[1].stride) + (integer(kind=8)) i] = (real(kind=8)) (((real(kind=4)) j - (real(kind=4)) k) + 1.000000047497451305389404296875e-3);
                      (*(real(kind=8)[0:] * restrict) b.data)[((b.offset + (integer(kind=8)) k * b.dim[2].stride) + (integer(kind=8)) j * b.dim[1].stride) + (integer(kind=8)) i] = (real(kind=8)) (((real(kind=4)) k - (real(kind=4)) j) + 2.0e+0);
                      L.5:;
                      k = k + 1;
                    }
                  }
                L.6:;
                L.3:;
                j = j + 1;
              }
            }
          L.4:;
          L.1:;
          i = i + 1;
        }
      }
    L.2:;
    i = 1;
    while (1)
      {
        {
          logical(kind=4) D.3804;

          D.3804 = i > 1000;
          if (D.3804) goto L.8;
          {
            integer(kind=8) D.3805;
            integer(kind=8) D.3806;
            integer(kind=8) D.3807;
            integer(kind=8) D.3808;
            integer(kind=8) D.3809;
            struct array02_real(kind=8) parm.2;
            integer(kind=8) D.3817;
            integer(kind=8) D.3818;
            integer(kind=8) D.3819;
            integer(kind=8) D.3820;
            integer(kind=8) D.3821;
            integer(kind=8) D.3822;
            struct array02_real(kind=8) parm.3;
            integer(kind=8) D.3824;
            integer(kind=8) D.3825;

            D.3805 = a.dim[0].lbound;
            D.3806 = a.dim[0].ubound;
            D.3807 = a.dim[1].lbound;
            D.3808 = a.dim[1].ubound;
            D.3809 = (integer(kind=8)) i;
            parm.2.dtype = {.elem_len=8, .rank=2, .type=3};
            parm.2.dim[0].lbound = D.3805;
            parm.2.dim[0].ubound = D.3806;
            parm.2.dim[0].stride = 1;
            D.3817 = a.dim[1].stride;
            parm.2.dim[1].lbound = D.3807;
            parm.2.dim[1].ubound = D.3808;
            parm.2.dim[1].stride = NON_LVALUE_EXPR <D.3817>;
            parm.2.data = (void *) &(*(real(kind=8)[0:] * restrict) a.data)[((D.3805 - a.dim[0].lbound) + (D.3807 - a.dim[1].lbound) * D.3817) + (D.3809 - a.dim[2].lbound) * a.dim[2].stride];
            parm.2.offset = 0;
            D.3818 = b.dim[1].lbound;
            D.3819 = b.dim[1].ubound;
            D.3820 = b.dim[2].lbound;
            D.3821 = b.dim[2].ubound;
            D.3822 = (integer(kind=8)) i;
            parm.3.dtype = {.elem_len=8, .rank=2, .type=3};
            D.3824 = b.dim[1].stride;
            parm.3.dim[0].lbound = D.3818;
            parm.3.dim[0].ubound = D.3819;
            parm.3.dim[0].stride = NON_LVALUE_EXPR <D.3824>;
            D.3825 = b.dim[2].stride;
            parm.3.dim[1].lbound = D.3820;
            parm.3.dim[1].ubound = D.3821;
            parm.3.dim[1].stride = NON_LVALUE_EXPR <D.3825>;
            parm.3.data = (void *) &(*(real(kind=8)[0:] * restrict) b.data)[((D.3822 - b.dim[0].lbound) + (D.3818 - b.dim[1].lbound) * D.3824) + (D.3820 - b.dim[2].lbound) * D.3825];
            parm.3.offset = 0;
            my_matrix_add (&parm.2, &parm.3);
          }
          {
            integer(kind=8) D.3833;
            integer(kind=8) D.3834;
            integer(kind=8) D.3835;
            integer(kind=8) D.3836;
            integer(kind=8) D.3837;
            struct array02_real(kind=8) parm.4;
            integer(kind=8) D.3839;
            integer(kind=8) D.3840;
            struct array02_real(kind=8) parm.5;
            integer(kind=8) D.3842;
            integer(kind=8) D.3843;

            D.3833 = a.dim[0].lbound;
            D.3834 = a.dim[0].ubound;
            D.3835 = a.dim[1].lbound;
            D.3836 = a.dim[1].ubound;
            D.3837 = (integer(kind=8)) i;
            parm.4.dtype = {.elem_len=8, .rank=2, .type=3};
            parm.4.dim[0].lbound = D.3833;
            parm.4.dim[0].ubound = D.3834;
            parm.4.dim[0].stride = 1;
            D.3839 = a.dim[1].stride;
            parm.4.dim[1].lbound = D.3835;
            parm.4.dim[1].ubound = D.3836;
            parm.4.dim[1].stride = NON_LVALUE_EXPR <D.3839>;
            parm.4.data = (void *) &(*(real(kind=8)[0:] * restrict) a.data)[((D.3833 - a.dim[0].lbound) + (D.3835 - a.dim[1].lbound) * D.3839) + (D.3837 - a.dim[2].lbound) * a.dim[2].stride];
            parm.4.offset = 0;
            D.3840 = (integer(kind=8)) i;
            parm.5.dtype = {.elem_len=8, .rank=2, .type=3};
            D.3842 = b.dim[1].stride;
            parm.5.dim[0].lbound = 10;
            parm.5.dim[0].ubound = 100;
            parm.5.dim[0].stride = NON_LVALUE_EXPR <D.3842>;
            D.3843 = b.dim[2].stride;
            parm.5.dim[1].lbound = 1;
            parm.5.dim[1].ubound = 50;
            parm.5.dim[1].stride = NON_LVALUE_EXPR <D.3843>;
            parm.5.data = (void *) &(*(real(kind=8)[0:] * restrict) b.data)[((D.3840 - b.dim[0].lbound) + (10 - b.dim[1].lbound) * D.3842) + (1 - b.dim[2].lbound) * D.3843];
            parm.5.offset = 0;
            my_matrix_add (&parm.4, &parm.5);
          }
          L.7:;
          i = i + 1;
        }
      }
    L.8:;
  }
}


__attribute__((externally_visible))
main (integer(kind=4) argc, character(kind=1) * * argv)
{
  static integer(kind=4) options.6[7] = {68, 8191, 0, 1, 1, 0, 31};

  _gfortran_set_args (argc, argv);
  _gfortran_set_options (7, &options.6[0]);
  vector_1 ();
  return 0;
}


